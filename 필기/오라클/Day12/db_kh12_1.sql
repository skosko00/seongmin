-- 트리거 실습을 위한 테이블 2개 생성
-- 회원 테이블, 탈퇴 회원 테이블

CREATE TABLE M_TBL
(
    USERID VARCHAR2(20) PRIMARY KEY,
    USERPWD VARCHAR2(20) NOT NULL,
    USERNAME VARCHAR2(20) NOT NULL,
    ENROLL_DATE DATE
);

CREATE TABLE DEL_M_TBL
(
    USERID VARCHAR2(20) PRIMARY KEY,
    USERNAME VARCHAR2(20) NOT NULL,
    ENROLL_DATE DATE,
    OUT_DATE DATE
);
INSERT INTO M_TBL
VALUES('USER11','PASS11','노민수','16/05/23');
INSERT INTO M_TBL
VALUES('USER22','PASS22','한아름','17/05/03');
INSERT INTO M_TBL
VALUES('USER33','PASS33','황누리','17/04/13');
INSERT INTO M_TBL
VALUES('USER44','PASS44','한영진','15/04/27');

DELETE FROM M_TBL WHERE USERID= 'USER22';

DECLARE
    ID M_TBL.USERID%TYPE;
    NAME M_TBL.USERNAME%TYPE;
    EN_DATE M_TBL.ENROLL_DATE%TYPE;
BEGIN
    SELECT USERID,USERNAME,ENROLL_DATE
    INTO ID, NAME, EN_DATE
    FROM M_TBL
    WHERE USERID = 'USER22';
    INSERT INTO DEL_M_TBL VALUES (ID,NAME,EN_DATE,SYSDATE);
    DELETE FROM M_TBL WHERE USERID = 'USER22';
END;
/

CREATE OR REPLACE TRIGGER M_TBL_TNG
AFTER DELETE
ON M_TBL
FOR EACH ROW
BEGIN
    INSERT INTO DEL_M_TBL VALUES(
        :OLD.USERID,:OLD.USERNAME,:OLD.ENROLL_DATE,SYSDATE);
END;
/

SELECT * FROM M_TBL;
SELECT * FROM DEL_M_TBL;
DELETE FROM M_TBL WHERE USERID= 'USER22';

COMMIT;
ROLLBACK;

CREATE OR REPLACE TRIGGER M_TBL_INSERT_TNG
AFTER INSERT
ON M_TBL
FOR EACH ROW
BEGIN
    DBMS_OUTPUT.PUT_LINE(:NEW.USERNAME || '님이 신규가입 하셨습니다.');
END;
/
SET SERVEROUTPUT ON;
INSERT INTO M_TBL VALUES('kh','kh11','케이','16/09/09');
INSERT INTO M_TBL VALUES('babo','kh33','천재','15/02/02');
INSERT INTO M_TBL VALUES('ttt','kh44','트와이스','13/03/09');
INSERT INTO M_TBL VALUES('ttt123','kh44','트','13/03/30');
COMMIT;

DELETE FROM M_TBL WHERE USERID= 'kh';

/*
## 간단 실습 1 ##
-> M_TBL 에서 회원 정보 (이름 변경시 LOG_TBL에 기록 남기기)
-> LOG_TBL 컬럼 (유저ID,로그내용,날짜)
    ※ 유저 ID : 로그가 남는 유저 ID
    ※ 로그내용 : 변경전 이름 -> 변경후 이름 내용
    ※ 날짜 : 실행한 시각
*/

CREATE TABLE LOG_TBL
(
    USERID VARCHAR(20) PRIMARY KEY,
    CONTENT VARCHAR(100) NOT NULL,
    MODIFY_DATE DATE
);

CREATE OR REPLACE TRIGGER M_TBL_UPDATE_TRG
AFTER UPDATE
ON M_TBL
FOR EACH ROW
DECLARE

BEGIN
    INSERT INTO LOG_TBL VALUES(
    :OLD.USERID,:OLD.USERNAME || ' -> ' || :NEW.USERNAME, SYSDATE);
END;
/
SELECT * FROM M_TBL;

UPDATE M_TBL
SET USERNAME='김말똥'
WHERE USERID='USER11';

SELECT * FROM LOG_TBL;

/*
ex)
제품이 입고 될때마다 상품 재고 테이블의 수치를 자동으려 변경하는 트리거 만들기
(입,출고 될 때마다 관리자가 수동으로 수치를 조정하면 불편하고 일이 많아짐)

2개의 테이블
1. 제품 및 재고 테이블
2. 입출고 테이블
*/

-- 제품 및 재고 테이블
CREATE TABLE PRODUCT
(
    PCODE NUMBER PRIMARY KEY,
    PNAME VARCHAR2(30),
    BRAND VARCHAR2(30),
    PRICE NUMBER,
    STOCK NUMBER DEFAULT 0
);

-- 제품 입출고 테이블
CREATE TABLE PRO_DETAIL
(
    DCODED NUMBER PRIMARY KEY,
    PCODE NUMBER,
    PDATE DATE,
    AMOUNT NUMBER,
    STATUS VARCHAR2(10) CHECK (STATUS IN('입고','출고')),
    FOREIGN KEY (PCODE) REFERENCES PRODUCT(PCODE)
);

INSERT INTO PRODUCT 
VALUES(1111,'칸쵸','롯데',1500,DEFAULT);
INSERT INTO PRODUCT 
VALUES(2222,'시리얼','롯데',3000,DEFAULT);
INSERT INTO PRODUCT 
VALUES(3333,'허니버터','해태',10000,DEFAULT);
INSERT INTO PRODUCT 
VALUES(4444,'꼬북칩','오리온',100,DEFAULT);
SELECT * FROM PRODUCT;
COMMIT;

SELECT * FROM PRODUCT;
CREATE SEQUENCE P_D_SEQ
START WITH 1
INCREMENT BY 1
MAXVALUE 10000
NOCYCLE
NOCACHE;

INSERT INTO PRO_DETAIL 
VALUES(P_D_SEQ.NEXTVAL,1111,SYSDATE,5,'입고');

SELECT * FROM PRO_DETAIL;

UPDATE PRODUCT
SET STOCK = STOCK + 5
WHERE PCODE = 1111;

-- 하나하나 작업하게 되면 굉장히 불편함
-- 트리거를 이용하여 입, 출고 내역에 따라 재고수량이 자동으로 변경되도록
-- 만들도록 하겠음
CREATE OR REPLACE TRIGGER PRO_TGR
AFTER INSERT
ON
PRO_DETAIL
FOR EACH ROW
BEGIN
    IF (:NEW.STATUS = '입고')
    THEN
        UPDATE PRODUCT
        SET STOCK = STOCK + :NEW.AMOUNT
        WHERE PCODE = :NEW.PCODE;
    ELSIF (:NEW.STATUS = '출고')
    THEN   
        UPDATE PRODUCT
        SET STOCK = STOCK - :NEW.AMOUNT
        WHERE PCODE = :NEW.PCODE;
    END IF;
END;
/

INSERT INTO PRO_DETAIL 
VALUES(P_D_SEQ.NEXTVAL,1111,SYSDATE,5,'입고');

INSERT INTO PRO_DETAIL 
VALUES(P_D_SEQ.NEXTVAL,1111,SYSDATE,2,'출고');

SELECT * FROM PRODUCT;
SELECT * FROM PRO_DETAIL;
