

@ 메소드 (Method)
-> 메소드는 타 언어에서는 함수(function)라고 부름
-> 우리가 기존에 작성하던 공간(main 및 기타 메소드)도 하나의 메소드임
-> 메소드를 사용하게 됨으로써 기능별 구분을 할 수 있게 됨
-> 재사용하는 코드들은 메소드로 정의함으로써 불필요한 중복 코드들을 줄 일 수 있음
-> 메소드명은 해당 기능명을 작성하는게 원칙이고, 낙타표기법을 따름


@ 메소드의 형태
public int sum (int a, int b)
{
	int c;
	c = a+b;
	return c;
}


public 반환형 메소드명(매개변수)
{
	메소드 실행 코드
	return 값;
}


메소드를 작성할 때 Tip
-> 순서대로 만들면 쉽게 제작이 가능 함

1. 기본틀을 작성 함
2. 메소드명을 수정 함
3. 매개변수를 수정 함
4. 실행 코드를 수정 함
5. 리턴 데이터 타입을 수정 함




Caller : 호출 한 메소드
Callee : 호출 당한 메소드



public int sum (int a, int b)
{
	int c;
	c = a+b;
	return c;
}



public : 접근 제어 지시자 (뒤에 배우므로 지금은 무조건 메소드 생성시 public을 쓰세요)
int : 리턴 데이터 타입 (반환 형태 - 반환하는 값의 데이터 타입)
sum : 메소드 명 (호출시 필요한 메소드 이름)
(int a, int b) : 매개 변수 (Parameter) 
		-> 호출시 보낸값 (인자 혹은 인수(argument))을 저장하는 변수

{ 코드; } : 해당 메소드 호출시 실행하는 코드
return c; : 호출이 끝나면 돌아갈때 가져가는 값

	※ 메소드는 리턴값이 있을 경우 리턴 데이터 타입이 명확해야 함
	※ 리턴값이 없는 경우에는 void 형을 사용 함
	※ 매개변수가 없는 경우에는 매개 변수 부분을 비워 놓음 -> public int sum()






@ 메소드의 구분
-> 메소드는 전달인자(argument)와 반환값(return value)의 유무에 따라
4가지 유형이 있음

1. 전달인자(O), 반환값(O)
2. 전달인자(O), 반환값(X)
3. 전달인자(X), 반환값(O)
4. 전달인자(X), 반환값(X)



1. 전달인자(O), 반환값(O) 인 경우의 메소드

public int sum(int su1, int su2)
{
	return su1+su2;
}


2. 전달인자(O), 반환값(X) 인 경우의 메소드

public void printValue(int a)
{
	System.out.println(a);
}


3. 전달인자(X), 반환값(O) 인 경우의 메소드

public int inputValue()
{
	Scanner sc = new Scanner(System.in);
	int a = sc.nextInt();
	return a;
}


4. 전달인자(X), 반환값(X) 인 경우의 메소드

public void onlyPrint()
{
	System.out.println("수고하셨습니다.");
}	






@ 메소드의 메모리 처리
-> 메소드 안에서 생성되는 변수들은 해당 메소드에서만 사용이 가능함
	- 해당 메소드에서만 사용이 가능하기 때문에 이름 중복 문제가 발생하지 않음





@ 메소드의 호출 방식
-> 메소드를 호출할 때 인수(혹은 인자)를 전달하는 방식

전달방식에 따른 2가지 방식

값에 의한 호출 (Call By Value)
	-> 인수의 값을 호출한 메소드에 전달
	-> 원본 값 수정 불가

참조에 의한 호출 (Call By Reference)
	-> 인수의 주소를 호출한 메소드에 전달
	-> 원본 값 수정 가능





























