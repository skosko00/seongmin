
@ 추상 클래스 (미완성된 클래스)
-> 객체 생성을 막아놓은 클래스
	ex) public abstact class 클래스형{ }
-> 클래스 안에 추상 메소드를 가지고 있으면 해당 클래스는 반드시 추상 클래스가 되어야 함
	- 추상 클래스를 상속받은 후손 클래스는 반드시 부모의 추상 메소드를 완성
	시켜야 하는 강제성이 부여 됨
	=> 후손은 추상 메소드를 반드시 오버라이딩 선언 해두어야 함


	※ 추상 메소드 (미완성된)
	-> 메소드의 헤드(Head)만 있고, 몸체(Body : 내용)가 없는 메소드
	ex) public abstract 반환자료형 메소드명([자료형 매개변수]);
	// 표준화된 인터페이스를 제공할 목적으로 추상메소드를 사용 함
	// 메소드 사용의 통일성을 확보하고 메소드 제작을 강제화 함

-> 추상 클래스는 추상 메소드가 없어도 명시 할 순 있음 (객체 생성 방지 목적)


@ 인터페이스(interface)
-> 상수형 필드와 추상 메소드로만 구성된 추상 클래스의 변형체
-> 클래스에 추상메소드를 포함시키는 구조보다는 메소드의 통일성을 부여하기 위해서
추상 메소드만 따로 모아 놓은 추상 클래스
-> 인터페이스의 멤버는 반드시 public 임
	- 필드는 상속이 아닌 인터페이스 것이기 때문에 public으로 되어 있어야 사용 가능함

[public] interface 인터페이스명
{
	// 상수형 필드 : 필드명은 대문자로 지어줌
	// 그냥 작성하여도 자동으로 static final이 됨
	[public]  static final 자료형 필드명 = 초기값;

	// 추상 메소드
	[public abstract] 반환형 메소드명([자료형 매개변수]);
}

※ 상수형 필드는 자동으로 선언되어 있는 것이고, 추상 메소드는
후손이 꼭 만들어야 하는 것임

@ 인터페이스의 사용
-> 상속을 통해서 후손이 부모 인터페이스의 추상 메소드를 완성 시키는 방식 임
-> interface를 상속 할 때에는 implements 라는 키워드를 사용해야 함

* 클래스의 상속 : extends 부모클래스명(단일 상속)
* 인터페이스의 상속 : implements 인터페이스명 (다중상속 가능)

ex) 다중
class 클래스명 extends 클래스명 implements 인터페이스명
{ }

class 클래스명 implements 인터페이스명1, 인터페이스명2, 인터페이스명3 ...
{ }
-> 다중 선언이 가능함
※ 인터페이스 간에도 상속이 가능함
interface 인터페이스명 extends 부모인터페이스명 {}